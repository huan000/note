<?php
/**
 * Created by PhpStorm.
 * User: huan
 * Date: 2017/8/27
 * Time: 20:02
 */
  class Test {
        public static function a(){
            echo get_class();
        }
  }

  class B extends Test{

  }

   $o = new B();
   $o->a();

die;



/**
 *  面向对象
 *  类于对象的关系：  类是对象的设计图。
 *  内存关系
 *  代码区，数据区(有栈区也有堆区，如果数据的大小预先可以确定在栈区，如果不能确定在堆区)，临时资源区
 *
 *  代码区： (没有实例化的时候)
 *  声名一个类的时候，类和类中的属性会存在于代码区。
 *  类中的方法和类的级别是一样的。也会在编译之后存在于代码区
 *
 *  数据区： (对象实例化的时候) (对象是在堆区的；对象的空间是不确定的)
 *  当一个类被实例化之后，会在数据区生成这个对象的数据空间，包含这个对象的属性的空间
 *  数据区还会保存装着这个对象的变量 ，保存在数据区的变量列表里面 (这是一个栈区)
 *
 */


/**   属性的操作
 *   类名：  不区分大小写  推荐使用(大驼峰)
 *   可变类名 ：  实例化的时候，类名可以用类名来充当
 *
 *   语法上可以先实例化类在定义类。  因为函数和类可以预处理，在代码编译的时候就已经存在于代码区了；
 *   但是require 进来的类不可以。 因为require 也要在编译执行， 而之前的实例化已经执行过了一遍了
 *
 *   属性：
 *   默认没有初始化并赋值的时候是null；
 *   $obj->attribute = 'xx';            这是修改
 *   如果当前类没有 hidden 这个属性
 *   $obj->hidden = 'xx';               这个是增加
 *
 *   isset()   判断属性如果值是null 或者 属性不存在 都会返回false
 *
 *   准确判断一个类的属性是否存在，如果存在属性值是null，那么属性也是存在的
 *   property_exists();
 *
 *   属性的删除
 *   unset($obj->hidden)
 *
 */


/**
 *  方法的操作： 方法存在于代码区里，不会因为实例化了一个对象而在数据区新开辟一个空间
 *             所有的对象公用相同的方法。 方法是可执行性代码的集合
 *
 *            方法的使用
 *               $obj->function();
 *            可变方法的使用
 *               $obj->$functionname();
 *
 *
 */


/**
 *  对象的判断：
 *            两个对象如果完全一样   $obj == $obj1     返回true
 *                                 $obj === $ovj1     返回false
 *            只有   $obj === $obj                     这样才返回true
 *
 *            $obj instanceof class                   判断一个对象是不是一个类的实例
 */


/**
 *  构造方法和析构方法
 *     析构方法 __destruct()
 *     使用场景 : 1.  在对象被销毁的时候进行一些数据的处理
 *                2.  如果一个对象生成了资源，unset($obj)的时候不会删除掉这个资源
 *                    __destruct(mysql_close($this->link));     卸载对象的时候删除这个资源
 *
 *     如何销毁一个对象：
 *           1. 脚本结束
 *           2. unset($obj)
 *           3. $obj = new obj    重新对一个对象赋值
 *
 */

/**
 *  对象间属性的赋值
 *      无论是值传递还是引用传递的效果都是引用传递的效果。
 *      对象间的值传递 传递的是对象的符号      obj  ---》   #1obj   ---》  变量
 *      所以对象中出现引用传递是没有意义的
 *
 *      ps ： 所以一个对象无论如何赋值都是指向#obj符号的，得到的都是原来的对象
 *
 *
 *  数据间的引用传递：
 *      两个变量指向同一个内存空间。 当一个变量改变了内存空间的数据，另一个也会发生改变
 *
 *
 *  对象的克隆：
 *      通过已有的对象，得到一个新的对象，新的对象的#obj对象标识是不一样的
 *      区分克隆对象，可以在克隆的时候改变对象的属性
 *      public function __clone(){
            $this->isclone = true;
 *      }
 *      深克隆与浅克隆：
 *      默认是浅克隆，只克隆当前对象的属性，如果一个对象的属性的值还是一个对象，则无法继续克隆#obj标志是一样的
 *      深度克隆：
 *      public function __clone(){
            $this->property = clone $this->property;     //把是对象的属性再次进行克隆
 *      }
 *
 *
 *
 *  得到一个新对象的方法
 *      1.从新实例化一个原始属性的对象
 *      2.对现有对象进行克隆
 */


/**
 *  静态成员：
 *       属于类，被所有对象所共享,类进行调用
 *       调用： 类内： 类名：：
 *                     self ：：
 *                     $this ::  （不推荐这么使用）
 *  非静态相对：
 *       属于对象，只被当前对象所使用，对象独有
 *
 *  静态局部变量：
 *       1.不会随着函数的调用和退出而发生变化，不过，尽管该变量还继续存在，
 *         但不能使用它。倘若再次调用定义它的函数时，它又可继续使用，而且保存了前次被调用后留下的值
 *
 *       2.静态局部变量只会初始化一次
 *
 *       3.静态属性只能被初始化为一个字符值或一个常量，不能使用表达式。
 *         即使局部静态变量定义时没有赋初值，系统会自动赋初值0（对数值型变量）或空字符
 *        （对字符变量）；静态变量的初始值为0。
 *
 *       4.当多次调用一个函数且要求在调用之间保留某些变量的值时，可考虑采用静态局部变量。
 *         虽然用全局变量也可以达到上述目的，但全局变量有时会造成意外的副作用，
 *         因此仍以采用局部静态变量为宜。
 *  静态局部变量声明：
 *         function a(){
                static $a;
 *              echo $a;
 *          }
 *
 *
 *
 *      静态方法和静态属性的意思是一样的
 *      ps :  静态方法内是不能有$this 出现的。 因为静态方法是属于类的
 *
 *      ps:
 *      针对方法：
 *      在类外对象可以访问静态方法也可以访问非静态方法，差别是方法中不能存在$this
 *      在类外类可以访问静态方法也可以访问非静态方法，差别是方法中不能存在$this ， 类访问非静态方法会报告一个非致命错误
 *      针对属性：
 *      在类外对象可以访问非静态属性而不能访问静态属性
 *      在类外类可以访问静态属性不能访问非静态属性
 *
 */


/**
 *  类常量的定义：
 *      定于 ：const GENDER = 1;
 *      使用 ：class::GENDER;
 *
 *  类常量的作用：
 *      1. 类常量不可以被改变 (静态属性也会被修改)
 *
 *  类常量的作用域： 只要可以访问到类就可以访问到类常量
 *
 *  const 在类外声明常量  和  define 的区别
 *    const NUM = $num;             //  这样是错误的，const 只能声明字符串
 *    define('NUM',$num);           //  这样声明是可以的
 *
 */


/**
 *  继承：
 *    单继承：
 *    一个类只可以有一个父类，一个类可以被多个类继承
 *    重写：
 *    如果子类和父类有同名的成员，子类会覆盖父类的属性或者方法
 *
 *    静态属性的继承：
 *    如果两个类都继承一个父类，其中一个改变了一个父类的静态属性，另一个子类集成过来
 *    静态属性也会发生改变
 *
 *    如果想改变这种情况，需要在自身子类中添加一个同名的静态属性，重写一下，之后在改变的就是自己
 *    的静态属性了
 */


/**
 *    访问修饰限定符：
 *     私有成员永远不能被重写，只能被继承。 导致的语法效果就是，在哪个类中访问到的就是哪个类的成员
 */


/**
 *    抽象类，最终类，接口
 *      抽象类：
 *          1.是继承链中的源头， 抽象类仅仅可以被继承， 不能够实例化。
 *          2.如果一个类是抽象类可以没有抽象方法。 一个抽象方法必须在一个抽象类里面
 *          3.一个抽象方法必须被重写实现。 除非这个子类也是一个抽象类
 *      抽象方法：
 *          abstract public function($n1,$n2);
 *
 *      最终类：
 *          仅仅可以实例化，不能够被继承。
 *        最终方法：
 *          final方法用于限制该方法不能被重写。 final 方法主要出现在非最终类。
 *          一个final类出现final方法是没有意义的
 *
 *      接口类：
 *        用于限定类(对象)应该具有的接口方法(公共方法)的一种技术。 称之为接口技术。
 *        接口类中只能出现抽象方法(不用写abstract关键字)  而抽象类中可以定义抽象方法或者普通方法
 *        继承是单继承， 而实现是多实现： 就是一个类可以同时实现多个接口类。
 *        接口之间是否可以定义常量？
 *        接口之间是否可以相互继承？ 或者是否可以相互实现？ 是单继承还是多继承
 *
 *        实现接口： class xx implements xx{}
 */


 /**
  * $this 的使用：
  *     如果一个非静态方法被静态调用了，会将调用位置所拥有的对象环境(哪个对象调用)，传递
  *     到这个被调用的方法中去。
  *     $this 不是永远代表所在类的对象的，根据对象环境的向下传递影响
  *
  *
  * 静态延迟绑定：
  *     self 永远代表其所在类。 和调用者没有关系。
  *     原因： 因为类在编译的时候就已经确定了其和类的绑定关系。
  *     实际逻辑： 但是往往当前类在调用一个父类的操作方法时，方法里的self想代表当前类
  *     就需要使用静态延迟绑定
  *
  *     父类中： static::$name;        static 代表当前调用类。   self 代表当前所在类
  */


/**
 *  类的自动加载：
 *      代码中的加载方案一：  一次性加载所有的代码， 方式类的重复加载。 缺点是浪费代码空间
 *
 *      方案二： 自动加载
 *          在代码运行到需要一个类的时候，判断该类是否已经存在，如果不存在，加载即可。
 *
 *      方法原理：
 *          php 程序运行时，发现当前代码需要一个类，并且该类没有被加载，此时php会自动触发
 *          魔术函数 __autoload(); 并且将当前所需要的类名传递到这个函数当中。
 *
 *          注册自己的自动加载函数：
 *          spl_autoload_register();
 *          在需要调用自动加载函数的时候，会依据注册顺序，一次调用所有的自动加载函数，
 *          直到加载成功(但是脚本过程中可能会被终止)
 *          因此：
 *
 */


/**单利模式
 * class Test{
        private static $instance;    //保存对象的引用 ，对象还没有的时候只能保存到类上
        private function __construct(){}            //私有化之后类外不能调用了 也就是说不能实例化了
                                                //现在只能在类内实例化了

        //得到对象的方法  必须是公有的， 因为不能实例化对象  所以必须是静态调用
        public static function get_instance(){
        if(!self::$instance instanceof self){
        //对象不存在
        new self();
        }
        return self::$instance;
        }
        private function __clone(){}
        }
 *
 *  ps: 在一个类的一个对象就可以完成所有功能的情况下才能够定义成单利模式
 *
 *
 *  单利模式架构函数：
 *      function getInstance($class_name){
 *          static $instance = array();
 *          if(isset($instance[$class_name]) && $instance[$class_name] instanceof $classname){
                return $instance[$class_name];
 *          } else {
                return $instance[$class_name] = new $class_name;
 *          }
 *      }
 *
 *   这种做法更灵活，但是第一种做法更彻底
 *
 *   工厂模式： 就是吧上述代码变成工厂类的方法，主要用于生产对象
 *             一般设置为静态的。因为工厂本身不需要实例化。
 *             一般一个工厂用于生产一类对象
 *
 *
 **/


/**
 *  魔术方法：
 *    __toString()  :   将对象转化成字符串类型的时候自动触发。  例子： echo $obj;
 *                        默认是不能将对象转化为数组的。 所以通过__toString(){return str}
 *                        返回一个字符串作为提示
 *
 *                        (string)true === '1'  (string)false === ''
 *
 *             重载：
 *                 (不是重复加载)
 *                 php 允许对 不可访问的成员 进行处理。 这种处理，称之为PHP的重载。
 *                 不可访问的成员：不存在，访问修饰限定符号限制的。
 *
 *             属性重载：
 *                 例如对一个不存在的属性进行赋值的时候（默认可以赋值），操作私有的属性（默认不可操作）
 *
 *    __set() :    当对一个不可访问的对象进行设置是，PHP会自动调用__set();  设置包含了修改和添加
 *                 例子：
 *                    public function __set($p_name,$p_value){
                           $allow_set=array('age','gender');
 *                         if(in_array($p_name,$allow_set)){
                                    $this->$p_name = $p_value;
 *                          }else{
                                    trigger_error('无权操作');
 *                          }
 *                    }
 *
 *    __get() ：    当对一个不可访问的属性进行设置的时候，会触发__get($p_name);
 *
 *
 *    __isset() ：   当判断一个不可访问的属性的时候，会触发该对象的__isset()方法
 *
 *    ——unset() :    当删除一个不可访问的属性的时候，会触发该魔术方法 __unset();
 *
 *
 *              方法重载：
 *    __call() :     当调用一个不存在的方法的时候 自动触发 __call($name,$args) 魔术方法
 *    __callStatic() :   当静态调用一个不存在的方法的时候   public static function __callStatic()
 *
 *    __wakeup() :   当对象在反序列化的时候触发。 例如在DB类反序列话的时候进行重新链接
 *
 *    __sleep() :    在执行序列话的时候执行。 例如DB类序列化的时候没有必要保存资源类型的属性
 *                   返回一个数组，数组中的元素就是要被序列化的元素。只是属性
 */


/**
 *  遍历对象：
 *      对象也是复合类型的数据， 数组也是符合类型的数据，所以都支持遍历。
 *
 *      对象中只有属性是数据，不是方法，因为方法是代码段存在于代码区；
 *
 *      foreach($obj as $k=>$v){
 *      }
 *
 *
 *   自定义遍历：
 *      rewind  初始化
 *      valid   验证合法性
 *      current  获得值变量
 *      key      获得键变量
 *      next     移动指针
 *
 *      class Test implement  Iterator{}
 */



/**
 *  序列化：
 *     serialize()      除了资源类型都可以被序列化成字符串
 *
 *     针对对象的序列化：
 *         1. 反序列话需要载入对象所属的类的定义代码才可以。 obj (_PHP_Incomplete_Class)
 *            ps: 反序列化的时候也可以触发自动加载机制
 *
 *         2. 如果一个类的属性是资源的话  $link = ziyuan;   序列化后会变成 0
 *            在反序列话的时候 利用魔术方法重新链接起来即可
 */


/**
 *  魔术常量：
 *      __CLASS__  :    所在的类名  Test   和self的区别 ： __CLASS__ 是类名 字符串形式  不可以__CLASS__::调用
 *      __METHOD__ :    所在的方法名   Test::info
 *      __FUNCTION__ :  所在的函数名   info
 *      __LINE__ :      显示当前所在的行号
 *      __DIR__ :       当前的目录
 *      __FILE__ :      当前文件的路径
 *
 *
 *   类的相关方法：
 *      class_exists()  :   类是否存在
 *      interface_exists() :  接口是否存在
 *      method_exists() :     方法是否存在
 *      property_exists() :   属性是否存在
 *      get_class_vars('Test')  :   得到类的所有属性 （只受访问权限的控制，不受静态与否的控制）
 *      get_object_vars($obj) :    得到对象的属性  会记录重载的属性
 *      get_class_method('Test') :  得到类的所有方法 （只受访问权限的控制，不受静态与否的控制）
 *      get_class($obj) :   得到一个对象的所属类 :  获得当前调用该方法的对象，如果是继承过来的，显示原始继承类。
 *      get_called_class() :  获得当前调用该方法的对象
 *      get_parent_class() :  得到这个类的父类
 *
 *
 *
 *
 *
 *
 *
 *
 */


